<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hand Pose Calculation Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; background: #000; color: white; font-family: sans-serif; overflow: hidden; touch-action: none; }
        canvas { position: absolute; left: 0; top: 0; width: 100vw; height: 100vh; object-fit: cover; }
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; text-align: center; }
        
        .hud-left { position: absolute; top: 10px; left: 15px; font-size: 24px; color: #0f0; text-shadow: 2px 2px 4px #000; font-weight: bold; z-index: 25; }
        .hud-right { position: absolute; top: 10px; right: 15px; font-size: 24px; color: #fff; text-shadow: 2px 2px 4px #000; font-weight: bold; z-index: 25; }
        
        #question-container { 
            position: absolute; 
            top: 0; 
            width: 100%; 
            height: 18%; 
            background: rgba(0,0,0,0.5); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            z-index: 10; 
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        #question { 
            font-size: 14vw; 
            color: #ff0; 
            text-shadow: 3px 3px 0px #f00, 0 0 15px rgba(0,0,0,1); 
            font-weight: bold; 
        }
        
        #msg { position: absolute; top: 55%; left: 50%; transform: translate(-50%, -50%); width: 90%; font-size: 40px; color: #0ff; text-shadow: 2px 2px 4px #000; white-space: pre-wrap; line-height: 1.4; z-index: 30; }
    </style>
</head>
<body>

    <video id="input_video" style="display:none;" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <div id="ui-layer">
        <div class="hud-left">Score: <span id="score">0</span></div>
        <div class="hud-right">Time: <span id="timer">60</span></div>
        <div id="question-container">
            <div id="question"></div>
        </div>
        <div id="msg">カメラ読み込み中...</div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const questionEl = document.getElementById('question');
        const msgEl = document.getElementById('msg');

        let score = 0, timeLeft = 60, gameActive = false;
        let targets = [], currentAnswer = 0, isProcessingNext = false;
        let isCooldown = false;
        let isCameraReady = false; 
        let canTouch = false; 
        let circleRadius;

        // 配置比率の定義（全体を上に移動：隙間を14%から7%へ）
        const TOP_ROW_RATIO = 0.25; // 0.32 -> 0.25
        const MID_ROW_RATIO = 0.43; // 0.50 -> 0.43
        const BOT_ROW_RATIO = 0.61; // 0.68 -> 0.61

        let audioCtx = null;

        function updateCanvasSize() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            circleRadius = Math.min(canvasElement.width, canvasElement.height) * 0.085;
            if (gameActive) generateTargets();
        }
        window.addEventListener('resize', updateCanvasSize);
        updateCanvasSize();

        function speak(text) {
            if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();
            const uttr = new SpeechSynthesisUtterance(text);
            uttr.lang = 'ja-JP';
            window.speechSynthesis.speak(uttr);
        }

        function generateTargets() {
            targets = [];
            const nums = Array.from({length: 10}, (_, i) => i + 1).sort(() => Math.random() - 0.5);
            
            const centerX = canvasElement.width / 2;
            const playableWidth = canvasElement.width * 0.8; 
            
            const topRowY = canvasElement.height * TOP_ROW_RATIO;    
            const middleRowY = canvasElement.height * MID_ROW_RATIO; 
            const bottomRowY = canvasElement.height * BOT_ROW_RATIO;

            for (let i = 0; i < 10; i++) {
                let xPos, yPos;
                if (i < 3) { 
                    xPos = centerX + (i - 1) * (playableWidth / 3);
                    yPos = topRowY;
                } else if (i < 7) { 
                    const spacing = (playableWidth / 4) * 1.25;
                    xPos = centerX + (i - 4.5) * spacing;
                    yPos = middleRowY;
                } else { 
                    xPos = centerX + (i - 8) * (playableWidth / 3);
                    yPos = bottomRowY;
                }
                targets.push({ x: xPos, y: yPos, num: nums[i] });
            }
        }

        function nextRound() {
            const a = Math.floor(Math.random() * 5) + 1;
            const b = Math.floor(Math.random() * 5) + 1;
            currentAnswer = a + b;
            questionEl.innerText = `${a} + ${b}`;
            generateTargets();
            isProcessingNext = false;
        }

        function startGame() {
            if (gameActive || isCooldown) return;

            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            score = 0; timeLeft = 60;
            scoreEl.innerText = score;
            gameActive = true;
            canTouch = false; 
            msgEl.innerText = "";
            nextRound();
            speak("スタート。手を下げて開始。");
            
            const timerInterval = setInterval(() => {
                if (!gameActive) { clearInterval(timerInterval); return; }
                timeLeft--;
                timerEl.innerText = timeLeft;
                if (timeLeft <= 0) endGame();
            }, 1000);
        }

        function endGame() {
            gameActive = false;
            questionEl.innerText = "";
            msgEl.innerText = "終了！\nスコア: " + score;
            speak(`${score}点です。終了。`);
            isCooldown = true;
            setTimeout(() => {
                isCooldown = false;
                if (!gameActive) msgEl.innerText = "1段目の高さまで手を上げてスタート";
            }, 3000);
        }

        function onResults(results) {
            if (!isCameraReady) {
                isCameraReady = true;
                msgEl.innerText = "1段目の高さまで手を上げてスタート";
            }

            const canvasW = canvasElement.width;
            const canvasH = canvasElement.height;

            const videoW = results.image.width;
            const videoH = results.image.height;
            const videoAspect = videoW / videoH;
            const canvasAspect = canvasW / canvasH;

            let drawW, drawH, dx, dy;
            if (canvasAspect > videoAspect) {
                drawW = canvasW; drawH = canvasW / videoAspect;
                dx = 0; dy = (canvasH - drawH) / 2;
            } else {
                drawH = canvasH; drawW = canvasH * videoAspect;
                dx = (canvasW - drawW) / 2; dy = 0;
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasW, canvasH);
            
            canvasCtx.save();
            canvasCtx.translate(canvasW, 0);
            canvasCtx.scale(-1, 1);
            canvasCtx.drawImage(results.image, (canvasW - drawW) / 2, dy, drawW, drawH);
            canvasCtx.restore();

            if (results.poseLandmarks) {
                const handIndices = [19, 20]; 
                let startSignal = false;
                let bothHandsLow = true;

                if (gameActive) {
                    targets.forEach(t => {
                        canvasCtx.fillStyle = (t.num === currentAnswer && isProcessingNext) ? "#0f0" : "rgba(255, 0, 0, 0.8)";
                        canvasCtx.beginPath();
                        canvasCtx.arc(t.x, t.y, circleRadius, 0, Math.PI * 2);
                        canvasCtx.fill();

                        canvasCtx.fillStyle = "#fff";
                        canvasCtx.font = `bold ${circleRadius * 1.2}px Arial`;
                        canvasCtx.textAlign = "center";
                        canvasCtx.textBaseline = "middle";
                        canvasCtx.strokeStyle = "black";
                        canvasCtx.lineWidth = 2;
                        canvasCtx.strokeText(t.num, t.x, t.y + 2); 
                        canvasCtx.fillText(t.num, t.x, t.y + 2);
                    });
                }

                handIndices.forEach(idx => {
                    const hand = results.poseLandmarks[idx];
                    if (!hand || hand.visibility < 0.5) return;
                    
                    const hx = (1 - hand.x) * drawW + (canvasW - drawW) / 2;
                    const hy = hand.y * drawH + dy;

                    canvasCtx.strokeStyle = canTouch ? "yellow" : "rgba(255, 255, 255, 0.3)";
                    canvasCtx.lineWidth = 6;
                    canvasCtx.beginPath();
                    canvasCtx.arc(hx, hy, circleRadius * 0.7, 0, Math.PI * 2);
                    canvasCtx.stroke();
                    
                    if (hand.y < TOP_ROW_RATIO && !isCooldown) startSignal = true;
                    if (hand.y < 0.70) bothHandsLow = false;

                    if (gameActive && !isProcessingNext && canTouch) {
                        targets.forEach(t => {
                            const dist = Math.sqrt((hx - t.x)**2 + (hy - t.y)**2);
                            if (dist < circleRadius) {
                                if (t.num === currentAnswer) {
                                    isProcessingNext = true;
                                    canTouch = false; 
                                    score++;
                                    scoreEl.innerText = score;
                                    playBeep();
                                    setTimeout(nextRound, 400);
                                }
                            }
                        });
                    }
                });

                if (!canTouch && bothHandsLow && !isProcessingNext) {
                    canTouch = true;
                }

                if (!gameActive && startSignal) startGame();
            }
            canvasCtx.restore();
        }

        function playBeep() {
            try {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(880, audioCtx.currentTime);
                osc.type = 'sine';
                osc.start();
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
                osc.stop(audioCtx.currentTime + 0.1);
            } catch(e) { console.error("Audio error:", e); }
        }

        const pose = new Pose({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` });
        pose.setOptions({ modelComplexity: 0, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        pose.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await pose.send({image: videoElement}); },
            width: {ideal: 640}, height: {ideal: 480}
        });
        camera.start();
    </script>
</body>
</html>