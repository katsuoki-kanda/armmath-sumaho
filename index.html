<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hand Pose Calculation Game - Refined Layout</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; background: #000; color: white; font-family: sans-serif; overflow: hidden; touch-action: none; }
        canvas { position: absolute; left: 0; top: 0; width: 100vw; height: 100vh; object-fit: cover; }
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; text-align: center; }
        
        /* スコア・タイマー表示（大） */
        .hud-left { position: absolute; top: 10px; left: 15px; font-size: 36px; color: #0f0; text-shadow: 2px 2px 4px #000; font-weight: bold; z-index: 25; }
        .hud-right { position: absolute; top: 10px; right: 15px; font-size: 36px; color: #fff; text-shadow: 2px 2px 4px #000; font-weight: bold; z-index: 25; }
        
        /* 問題表示の位置を下げてHUDとの重複を回避 */
        #question-container { 
            position: absolute; 
            top: 60px; /* スコア表示の下に来るように調整 */
            width: 100%; 
            height: 18%; 
            background: rgba(0,0,0,0.3); 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            z-index: 10; 
        }
        /* 問題表示（1.2倍） */
        #question { 
            font-size: 16.8vw; 
            color: #ff0; 
            text-shadow: 3px 3px 0px #f00, 0 0 15px rgba(0,0,0,1); 
            font-weight: bold; 
        }
        
        /* メッセージ表示（画面下部） */
        #msg { 
            position: absolute; 
            top: 82%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            width: 90%; 
            font-size: 32px; 
            color: #0ff; 
            text-shadow: 2px 2px 4px #000; 
            white-space: pre-wrap; 
            line-height: 1.4; 
            z-index: 30; 
        }
    </style>
</head>
<body>

    <video id="input_video" style="display:none;" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <div id="ui-layer">
        <div class="hud-left">Score: <span id="score">0</span></div>
        <div class="hud-right">Time: <span id="timer">60</span></div>
        <div id="question-container">
            <div id="question"></div>
        </div>
        <div id="msg">カメラ読み込み中...</div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const questionEl = document.getElementById('question');
        const msgEl = document.getElementById('msg');

        let score = 0, timeLeft = 60, gameActive = false;
        let targets = [], currentAnswer = 0;
        let waitingForNext = false; 
        let isCooldown = false;
        let isCameraReady = false; 
        let circleRadius;

        // 段の間隔を2/3に調整 (旧間隔 0.18 -> 新間隔 0.12)
        const TOP_ROW_RATIO = 0.25;
        const MID_ROW_RATIO = 0.37; // 0.25 + 0.12
        const BOT_ROW_RATIO = 0.49; // 0.37 + 0.12

        let audioCtx = null;

        function updateCanvasSize() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            circleRadius = Math.min(canvasElement.width, canvasElement.height) * 0.085;
            if (gameActive) generateTargets();
        }
        window.addEventListener('resize', updateCanvasSize);
        updateCanvasSize();

        function speak(text) {
            if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();
            const uttr = new SpeechSynthesisUtterance(text);
            uttr.lang = 'ja-JP';
            window.speechSynthesis.speak(uttr);
        }

        function generateTargets() {
            targets = [];
            const nums = Array.from({length: 10}, (_, i) => i + 1).sort(() => Math.random() - 0.5);
            const centerX = canvasElement.width / 2;
            const playableWidth = canvasElement.width * 0.8; 
            
            const rowYs = [
                canvasElement.height * TOP_ROW_RATIO,
                canvasElement.height * MID_ROW_RATIO,
                canvasElement.height * BOT_ROW_RATIO
            ];

            for (let i = 0; i < 10; i++) {
                let xPos, yPos;
                if (i < 3) { 
                    xPos = centerX + (i - 1) * (playableWidth / 3);
                    yPos = rowYs[0];
                } else if (i < 7) { 
                    const spacing = (playableWidth / 4) * 1.25;
                    xPos = centerX + (i - 4.5) * spacing;
                    yPos = rowYs[1];
                } else { 
                    xPos = centerX + (i - 8) * (playableWidth / 3);
                    yPos = rowYs[2];
                }
                targets.push({ x: xPos, y: yPos, num: nums[i] });
            }
        }

        function nextRound() {
            waitingForNext = false;
            msgEl.innerText = "";
            const a = Math.floor(Math.random() * 5) + 1;
            const b = Math.floor(Math.random() * 5) + 1;
            currentAnswer = a + b;
            questionEl.innerText = `${a} + ${b}`;
            generateTargets();
        }

        function startGame() {
            if (gameActive || isCooldown) return;
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            score = 0; timeLeft = 60;
            scoreEl.innerText = score;
            gameActive = true;
            nextRound();
            speak("スタート");
            
            const timerInterval = setInterval(() => {
                if (!gameActive) { clearInterval(timerInterval); return; }
                timeLeft--;
                timerEl.innerText = timeLeft;
                if (timeLeft <= 0) endGame();
            }, 1000);
        }

        function endGame() {
            gameActive = false;
            waitingForNext = false;
            questionEl.innerText = "";
            msgEl.innerText = "終了！\nスコア: " + score;
            speak(`${score}点です。終了。`);
            isCooldown = true;
            setTimeout(() => {
                isCooldown = false;
                if (!gameActive) msgEl.innerText = "両手を合わせてスタート！";
            }, 3000);
        }

        function onResults(results) {
            if (!isCameraReady) {
                isCameraReady = true;
                msgEl.innerText = "両手を合わせてスタート！";
            }

            const canvasW = canvasElement.width;
            const canvasH = canvasElement.height;
            const videoW = results.image.width;
            const videoH = results.image.height;
            const videoAspect = videoW / videoH;
            const canvasAspect = canvasW / canvasH;

            let drawW, drawH, dx, dy;
            if (canvasAspect > videoAspect) {
                drawW = canvasW; drawH = canvasW / videoAspect;
                dx = 0; dy = (canvasH - drawH) / 2;
            } else {
                drawH = canvasH; drawW = canvasH * videoAspect;
                dx = (canvasW - drawW) / 2; dy = 0;
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasW, canvasH);
            canvasCtx.translate(canvasW, 0);
            canvasCtx.scale(-1, 1);
            canvasCtx.drawImage(results.image, (canvasW - drawW) / 2, dy, drawW, drawH);
            canvasCtx.restore();

            if (results.poseLandmarks) {
                const leftHand = results.poseLandmarks[19];
                const rightHand = results.poseLandmarks[20];
                
                let isClapping = false;
                if (leftHand && rightHand && leftHand.visibility > 0.5 && rightHand.visibility > 0.5) {
                    const dist = Math.sqrt(Math.pow(leftHand.x - rightHand.x, 2) + Math.pow(leftHand.y - rightHand.y, 2));
                    if (dist < 0.06) isClapping = true; 
                }

                if (gameActive) {
                    // ターゲット描画
                    targets.forEach(t => {
                        canvasCtx.fillStyle = (t.num === currentAnswer && waitingForNext) ? "#0f0" : "rgba(255, 0, 0, 0.8)";
                        canvasCtx.beginPath();
                        canvasCtx.arc(t.x, t.y, circleRadius, 0, Math.PI * 2);
                        canvasCtx.fill();

                        canvasCtx.fillStyle = "#fff";
                        canvasCtx.font = `normal ${circleRadius * 1.2}px Arial`;
                        canvasCtx.textAlign = "center";
                        canvasCtx.textBaseline = "middle";
                        canvasCtx.strokeStyle = "rgba(0,0,0,0.4)";
                        canvasCtx.lineWidth = 1; 
                        canvasCtx.strokeText(t.num, t.x, t.y + 2); 
                        canvasCtx.fillText(t.num, t.x, t.y + 2);
                    });

                    // 手のポインター描画
                    [19, 20].forEach(idx => {
                        const hand = results.poseLandmarks[idx];
                        if (!hand || hand.visibility < 0.5) return;
                        
                        const hx = (1 - hand.x) * drawW + (canvasW - drawW) / 2;
                        const hy = hand.y * drawH + dy;

                        // 黄色のリングを1.2倍（0.6 -> 0.72）に拡大
                        canvasCtx.strokeStyle = "yellow";
                        canvasCtx.lineWidth = 6;
                        canvasCtx.beginPath();
                        canvasCtx.arc(hx, hy, circleRadius * 0.72, 0, Math.PI * 2);
                        canvasCtx.stroke();

                        if (!waitingForNext) {
                            targets.forEach(t => {
                                const dist = Math.sqrt((hx - t.x)**2 + (hy - t.y)**2);
                                if (dist < circleRadius && t.num === currentAnswer) {
                                    score++;
                                    scoreEl.innerText = score;
                                    playBeep();
                                    waitingForNext = true;
                                    msgEl.innerText = "正解！両手を合わせて次へ";
                                }
                            });
                        }
                    });

                    if (waitingForNext && isClapping) {
                        nextRound();
                    }
                } else {
                    if (isClapping && !isCooldown) startGame();
                }

                if (isClapping) {
                    const cx = (1 - (leftHand.x + rightHand.x)/2) * drawW + (canvasW - drawW) / 2;
                    const cy = ((leftHand.y + rightHand.y)/2) * drawH + dy;
                    canvasCtx.fillStyle = "rgba(0, 255, 255, 0.5)";
                    canvasCtx.beginPath();
                    canvasCtx.arc(cx, cy, circleRadius * 1.2, 0, Math.PI * 2);
                    canvasCtx.fill();
                }
            }
        }

        function playBeep() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(880, audioCtx.currentTime);
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
            osc.stop(audioCtx.currentTime + 0.1);
        }

        const pose = new Pose({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` });
        pose.setOptions({ modelComplexity: 0, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        pose.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await pose.send({image: videoElement}); },
            width: {ideal: 640}, height: {ideal: 480}
        });
        camera.start();
    </script>
</body>
</html>